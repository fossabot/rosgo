// Code generated by ros-gen-go.
// source: MultiDOFJointState.msg
// DO NOT EDIT!
package sensor_msgs

import (
	"io"
	"encoding/binary"
	"fmt"

	"github.com/ppg/rosgo/ros"
	"github.com/ppg/rosgo/msgs/geometry_msgs"
	"github.com/ppg/rosgo/msgs/std_msgs"
)

type _MsgMultiDOFJointState struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgMultiDOFJointState) Text() string {
	return t.text
}

func (t *_MsgMultiDOFJointState) Name() string {
	return t.name
}

func (t *_MsgMultiDOFJointState) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgMultiDOFJointState) NewMessage() ros.Message {
	m := new(MultiDOFJointState)

	return m
}

var (
	MsgMultiDOFJointState = &_MsgMultiDOFJointState{
		`# Representation of state for joints with multiple degrees of freedom, 
# following the structure of JointState.
#
# It is assumed that a joint in a system corresponds to a transform that gets applied 
# along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)
# and those 3DOF can be expressed as a transformation matrix, and that transformation
# matrix can be converted back to (x, y, yaw)
#
# Each joint is uniquely identified by its name
# The header specifies the time at which the joint states were recorded. All the joint states
# in one message have to be recorded at the same time.
#
# This message consists of a multiple arrays, one for each part of the joint state. 
# The goal is to make each of the fields optional. When e.g. your joints have no
# wrench associated with them, you can leave the wrench array empty. 
#
# All arrays in this message should have the same size, or be empty.
# This is the only way to uniquely associate the joint name with the correct
# states.

Header header

string[] joint_names
geometry_msgs/Transform[] transforms
geometry_msgs/Twist[] twist
geometry_msgs/Wrench[] wrench
`,
		"sensor_msgs/MultiDOFJointState",
		"ca6307bcc53f56ce3e190e089129c7f6",
	}
)

type MultiDOFJointState struct {
	Header     std_msgs.Header
	JointNames []string
	Transforms []geometry_msgs.Transform
	Twist      []geometry_msgs.Twist
	Wrench     []geometry_msgs.Wrench
}

func (m *MultiDOFJointState) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "Header", &m.Header); err != nil {
		return err
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.JointNames)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.JointNames {
		if err = ros.SerializeMessageField(w, "string", &elem); err != nil {
			return err
		}
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Transforms)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Transforms {
		if err = ros.SerializeMessageField(w, "geometry_msgs/Transform", &elem); err != nil {
			return err
		}
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Twist)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Twist {
		if err = ros.SerializeMessageField(w, "geometry_msgs/Twist", &elem); err != nil {
			return err
		}
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Wrench)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Wrench {
		if err = ros.SerializeMessageField(w, "geometry_msgs/Wrench", &elem); err != nil {
			return err
		}
	}

	return
}

func (m *MultiDOFJointState) Deserialize(r io.Reader) (err error) {
	// Header
	if err = ros.DeserializeMessageField(r, "Header", &m.Header); err != nil {
		return err
	}

	// JointNames
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for JointNames: %s", err)
		}
		m.JointNames = make([]string, int(size))
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "string", &m.JointNames[i]); err != nil {
				return err
			}
		}
	}

	// Transforms
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for Transforms: %s", err)
		}
		m.Transforms = make([]geometry_msgs.Transform, int(size))
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "geometry_msgs/Transform", &m.Transforms[i]); err != nil {
				return err
			}
		}
	}

	// Twist
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for Twist: %s", err)
		}
		m.Twist = make([]geometry_msgs.Twist, int(size))
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "geometry_msgs/Twist", &m.Twist[i]); err != nil {
				return err
			}
		}
	}

	// Wrench
	{
		// Read size little endian
		var size uint32
		if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
			return fmt.Errorf("cannot read array size for Wrench: %s", err)
		}
		m.Wrench = make([]geometry_msgs.Wrench, int(size))
		for i := 0; i < int(size); i++ {
			if err = ros.DeserializeMessageField(r, "geometry_msgs/Wrench", &m.Wrench[i]); err != nil {
				return err
			}
		}
	}

	return
}
