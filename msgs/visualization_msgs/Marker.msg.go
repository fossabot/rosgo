// Code generated by ros-gen-go.
// source: Marker.msg
// DO NOT EDIT!
package visualization_msgs

import (
	"io"
	"encoding/binary"
	"fmt"

	"github.com/ppg/rosgo/ros"
	"github.com/ppg/rosgo/msgs/std_msgs"
)

type _MsgMarker struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgMarker) Text() string {
	return t.text
}

func (t *_MsgMarker) Name() string {
	return t.name
}

func (t *_MsgMarker) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgMarker) NewMessage() ros.Message {
	m := new(Marker)

	return m
}

var (
	MsgMarker = &_MsgMarker{
		`# See http://www.ros.org/wiki/rviz/DisplayTypes/Marker and http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes for more information on using this message with rviz

uint8 ARROW=0
uint8 CUBE=1
uint8 SPHERE=2
uint8 CYLINDER=3
uint8 LINE_STRIP=4
uint8 LINE_LIST=5
uint8 CUBE_LIST=6
uint8 SPHERE_LIST=7
uint8 POINTS=8
uint8 TEXT_VIEW_FACING=9
uint8 MESH_RESOURCE=10
uint8 TRIANGLE_LIST=11

uint8 ADD=0
uint8 MODIFY=0
uint8 DELETE=2
uint8 DELETEALL=3

Header header                        # header for time/frame information
string ns                            # Namespace to place this object in... used in conjunction with id to create a unique name for the object
int32 id 		                         # object ID useful in conjunction with the namespace for manipulating and deleting the object later
int32 type 		                       # Type of object
int32 action 	                       # 0 add/modify an object, 1 (deprecated), 2 deletes an object, 3 deletes all objects
geometry_msgs/Pose pose                 # Pose of the object
geometry_msgs/Vector3 scale             # Scale of the object 1,1,1 means default (usually 1 meter square)
std_msgs/ColorRGBA color             # Color [0.0-1.0]
duration lifetime                    # How long the object should last before being automatically deleted.  0 means forever
bool frame_locked                    # If this marker should be frame-locked, i.e. retransformed into its frame every timestep

#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
geometry_msgs/Point[] points
#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
#number of colors must either be 0 or equal to the number of points
#NOTE: alpha is not yet used
std_msgs/ColorRGBA[] colors

# NOTE: only used for text markers
string text

# NOTE: only used for MESH_RESOURCE markers
string mesh_resource
bool mesh_use_embedded_materials
`,
		"visualization_msgs/Marker",
		"06f252f28e50b583ca77b8a19201f579",
	}
)

type Marker struct {
	Header                   std_msgs.Header
	Ns                       string
	ID                       int32
	Type                     int32
	Action                   int32
	Pose                     geometry_msgs.Pose
	Scale                    geometry_msgs.Vector3
	Color                    std_msgs.ColorRGBA
	Lifetime                 ros.Duration
	FrameLocked              bool
	Points                   []geometry_msgs.Point
	Colors                   []std_msgs.ColorRGBA
	Text                     string
	MeshResource             string
	MeshUseEmbeddedMaterials bool
}

func (m *Marker) Type() ros.MessageType {
	return MsgMarker
}

func (m *Marker) Serialize(w io.Writer) (err error) {
	if err = ros.SerializeMessageField(w, "Header", &m.Header); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "string", &m.Ns); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "int32", &m.ID); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "int32", &m.Type); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "int32", &m.Action); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "geometry_msgs/Pose", &m.Pose); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "geometry_msgs/Vector3", &m.Scale); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "std_msgs/ColorRGBA", &m.Color); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "duration", &m.Lifetime); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "bool", &m.FrameLocked); err != nil {
		return err
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Points)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Points {
		if err = ros.SerializeMessageField(w, "geometry_msgs/Point", &elem); err != nil {
			return err
		}
	}

	// Write size little endian
	err = binary.Write(w, binary.LittleEndian, uint32(len(m.Colors)))
	if err != nil {
		return fmt.Errorf("could not write array length: %s", err)
	}
	for _, elem := range m.Colors {
		if err = ros.SerializeMessageField(w, "std_msgs/ColorRGBA", &elem); err != nil {
			return err
		}
	}

	if err = ros.SerializeMessageField(w, "string", &m.Text); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "string", &m.MeshResource); err != nil {
		return err
	}

	if err = ros.SerializeMessageField(w, "bool", &m.MeshUseEmbeddedMaterials); err != nil {
		return err
	}

	return
}

func (m *Marker) Deserialize(r io.Reader) (err error) {
	// Header
	if err = ros.DeserializeMessageField(r, "Header", &m.Header); err != nil {
		return err
	}

	// Ns
	if err = ros.DeserializeMessageField(r, "string", &m.Ns); err != nil {
		return err
	}

	// ID
	if err = ros.DeserializeMessageField(r, "int32", &m.ID); err != nil {
		return err
	}

	// Type
	if err = ros.DeserializeMessageField(r, "int32", &m.Type); err != nil {
		return err
	}

	// Action
	if err = ros.DeserializeMessageField(r, "int32", &m.Action); err != nil {
		return err
	}

	// Pose
	if err = ros.DeserializeMessageField(r, "geometry_msgs/Pose", &m.Pose); err != nil {
		return err
	}

	// Scale
	if err = ros.DeserializeMessageField(r, "geometry_msgs/Vector3", &m.Scale); err != nil {
		return err
	}

	// Color
	if err = ros.DeserializeMessageField(r, "std_msgs/ColorRGBA", &m.Color); err != nil {
		return err
	}

	// Lifetime
	if err = ros.DeserializeMessageField(r, "duration", &m.Lifetime); err != nil {
		return err
	}

	// FrameLocked
	if err = ros.DeserializeMessageField(r, "bool", &m.FrameLocked); err != nil {
		return err
	}

	// Points
	// Read size little endian
	var size uint32
	if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
		return fmt.Errorf("cannot read array size for Points: %s", err)
	}
	m.Points = make([]geometry_msgs.Point, int(size))
	for i := 0; i < int(size); i++ {
		if err = ros.DeserializeMessageField(r, "geometry_msgs/Point", &m.Points[i]); err != nil {
			return err
		}
	}

	// Colors
	// Read size little endian
	var size uint32
	if err = binary.Read(r, binary.LittleEndian, &size); err != nil {
		return fmt.Errorf("cannot read array size for Colors: %s", err)
	}
	m.Colors = make([]std_msgs.ColorRGBA, int(size))
	for i := 0; i < int(size); i++ {
		if err = ros.DeserializeMessageField(r, "std_msgs/ColorRGBA", &m.Colors[i]); err != nil {
			return err
		}
	}

	// Text
	if err = ros.DeserializeMessageField(r, "string", &m.Text); err != nil {
		return err
	}

	// MeshResource
	if err = ros.DeserializeMessageField(r, "string", &m.MeshResource); err != nil {
		return err
	}

	// MeshUseEmbeddedMaterials
	if err = ros.DeserializeMessageField(r, "bool", &m.MeshUseEmbeddedMaterials); err != nil {
		return err
	}

	return
}
